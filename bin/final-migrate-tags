#!/usr/bin/env python
import click
from inbox.models.session import session_scope
from inbox.models import Message, Folder, Category, Label, Account
from inbox.models.backends.imap import ImapUid
from datetime import datetime
import dateutil.parser
from sqlalchemy import asc, func
from inbox.log import configure_logging, get_logger
configure_logging()
log = get_logger()


def create_categories_for_imap_folders(account, db_session):
    for folder in db_session.query(Folder).filter(
            Folder.account_id == account.id):
        cat = Category.find_or_create(
            db_session, namespace_id=account.namespace.id,
            name=folder.canonical_name, display_name=folder.name,
            type_='folder')
        folder.category = cat
    db_session.commit()


def create_categories_for_gmail_folders(account, db_session):
    for folder in db_session.query(Folder).filter(
            Folder.account_id == account.id):
        if folder.canonical_name in ('all', 'spam', 'trash'):
            cat = Category.find_or_create(
                db_session, namespace_id=account.namespace.id,
                name=folder.canonical_name, display_name=folder.name,
                type_='folder')
            folder.category = cat
        if folder.name is not None:
            Label.find_or_create(db_session, account, folder.name,
                                 folder.canonical_name)
    db_session.commit()


def create_categories_for_easfoldersyncstatuses(account, db_session):
    from inbox.mailsync.backends.eas.base.foldersync import save_categories
    if not account.foldersyncstatuses:
        return

    save_categories(db_session, account, account.primary_device_id)
    db_session.commit()
    save_categories(db_session, account, account.secondary_device_id)


def migrate_account_metadata(account_id):
    with session_scope(versioned=False) as db_session:
        account = db_session.query(Account).get(account_id)
        if account.discriminator == 'easaccount':
            create_categories_for_easfoldersyncstatuses(account, db_session)
        elif account.discriminator == 'gmailaccount':
            create_categories_for_gmail_folders(account, db_session)
        else:
            create_categories_for_imap_folders(account, db_session)
        db_session.commit()


def migrate_imapuids(start, end, task_id, num_tasks):
    offset = 0
    count = 0
    while True:
        with session_scope(versioned=False) as db_session:
            imapuids = db_session.query(ImapUid). \
                filter(ImapUid.updated_at >= start,
                       func.mod(ImapUid.id, num_tasks) == task_id). \
                order_by(asc(ImapUid.updated_at)). \
                limit(1000).offset(offset). \
                all()
            for uid in imapuids:
                if uid.updated_at > end:
                    return
                uid.update_labels(uid.g_labels)
                log.info('Updated labels', uid=uid.id,
                         updated_at=uid.updated_at, count=count)
                count += 1
                if uid.message is not None:
                    uid.message.updated_at = datetime.utcnow()
            offset += 1000


def migrate_messages(start, end, task_id, num_tasks):
    offset = 0
    count = 0
    while True:
        with session_scope(versioned=False) as db_session:
            messages = db_session.query(Message). \
                filter(Message.updated_at >= start,
                       func.mod(Message.id, num_tasks) == task_id). \
                order_by(asc(Message.updated_at)). \
                limit(1000).offset(offset).all()
            for message in messages:
                if message.updated_at > end:
                    return
                with db_session.no_autoflush:
                    message.update_metadata(message.is_draft)
                log.info('Updated message', message_id=message.id,
                         updated_at=message.updated_at, count=count)
                count += 1
            offset += 1000


@click.command()
@click.option('--start')
@click.option('--task_id', type=int)
@click.option('--num_tasks', type=int)
def run(start, task_id, num_tasks):
    start = dateutil.parser.parse(start)
    while True:
        end = datetime.utcnow()
        with session_scope() as db_session:
            q = db_session.query(Account). \
                filter(func.mod(Account.id, num_tasks) == task_id)
            account_ids = []
            for account in q:
                # Skip accounts that have been inactive for a long time.
                if (account.sync_state != 'stopped' or
                        (datetime.utcnow() - account.updated_at).days < 60):
                    account_ids.append(account.id)
        for id_ in account_ids:
            migrate_account_metadata(id_)
            log.info('Updated metadata for account', account_id=id_)
        migrate_imapuids(start, end, task_id, num_tasks)
        migrate_messages(start, end, task_id, num_tasks)
        log.info('Migrated UIDs and messages in update window',
                 start=start, end=end)
        start = end


if __name__ == '__main__':
    run()
